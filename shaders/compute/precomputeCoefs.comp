#version 460 core
/// #include "default/shaderBase.glsl"

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

uniform int clusterSize;

void main()
{
    uint index = gl_GlobalInvocationID.y * clusterSize + gl_GlobalInvocationID.x;
    Triangle tri = triangles[index];

    vec3 p1 = tri.vertices[0].posU.xyz, p2 = tri.vertices[1].posU.xyz, p3 = tri.vertices[2].posU.xyz;
    vec3 e1 = p2 - p1;
    vec3 e2 = p3 - p1;
    vec3 normal = cross(tri.vertices[1].posU.xyz - tri.vertices[0].posU.xyz, tri.vertices[2].posU.xyz - tri.vertices[1].posU.xyz);

    if (abs(normal.x) > abs(normal.y) && abs(normal.x) > abs(normal.z))
    {
        tri.rows[0] = vec4(0.0f, e2.z / normal.x, -e2.y / normal.x, cross(p3, p1).x / normal.x);
        tri.rows[1] = vec4(0.0f, -e1.z / normal.x, e1.y / normal.x, -cross(p2, p1).x / normal.x);
        tri.rows[2] = vec4(1.0f, normal.y / normal.x, normal.z / normal.x, -dot(p1, normal) / normal.x);
    }
    else if (abs(normal.y) > abs(normal.z))
    {
        tri.rows[0] = vec4(-e2.z / normal.y, 0.0f, e2.x / normal.y, cross(p3, p1).y / normal.y);
        tri.rows[1] = vec4(e1.z / normal.y, 0.0f, -e1.x / normal.y, -cross(p2, p1).y / normal.y);
        tri.rows[2] = vec4(normal.x / normal.y, 1.0f, normal.z / normal.y, -dot(p1, normal) / normal.y);
    }
    else if (abs(normal.z) > 0.0f)
    {
        tri.rows[0] = vec4(e2.y / normal.z, -e2.x / normal.z, 0.0f, cross(p3, p1).z / normal.z);
        tri.rows[1] = vec4(-e1.y / normal.z, e1.x / normal.z, 0.0f, -cross(p2, p1).z / normal.z);
        tri.rows[2] = vec4(normal.x / normal.z, normal.y / normal.z, 1.0f, -dot(p1, normal) / normal.z);
    }
    else
    {
        tri.rows[0] = vec4(0);
        tri.rows[1] = vec4(0);
        tri.rows[2] = vec4(0);
    }
    triangles[index] = tri;
}
