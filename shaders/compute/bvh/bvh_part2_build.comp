#version 460 core
#extension GL_ARB_shading_language_include : enable
#include "common.glsl"

layout(local_size_x = 32) in;

layout(std140, binding = 6) /*buffer*/ uniform BVHNodes
{
    BVHNode nodes[];
};

layout(std430, binding = 7) /*buffer*/ uniform BVHTriIndices
{
    uint triIndices[];
};

layout(std430, binding = 8) /*buffer*/ uniform MortonCodes
{
    uint mortonCodes[];
};

uniform int n = -1;
uniform int nodeOffset = 0;

#define NODE(i) nodes[(i) + nodeOffset]
#define CODE(i) mortonCodes[(i) + nodeOffset]

int lcp(uint i, uint j)
{
    if (i < 0 || i >= n || j < 0 || j >= n) return -1;
    return 31 - findMSB(CODE(i) ^ CODE(j));
}

void buildInnerNodes(int i)
{
    if (i >= n - 1) return;
    if (i == 0) NODE(i).values.w = -1;

    int dir = int(sign(lcp(i, i + 1) - lcp(i, i - 1)));
    int minPrefix = lcp(i, i - dir);

    int l_max = 128;
    while (lcp(i, i + l_max * dir) > minPrefix)
        l_max *= 4;

    int l = 0;
    for (int step = l_max / 2; step > 0; step /= 2) {
        if (lcp(i, i + (l + step) * dir) > minPrefix)
            l += step;
    }
    int j = i + l * dir;

    if (dir == 0)
        while (lcp(i, j) == lcp(i, j + 1))
            j++;

    int split;
    if (CODE(i) == CODE(j))
        split = min(i, j);
    else {
        int delta = lcp(i, j);
        int s = 0;
        int t = abs(j - i);
        for (int div = 2; t * 2 / div > 0; div *= 2) {
            int t_ = int(ceil(t / float(div)));
            if (lcp(i, i + (s + t_) * dir) > delta)
                s += t_;
        }
        split = i + s * dir + min(dir, 0);
    }

    int left = min(i, j) == split ? split + (n - 1) : split;
    int right = max(i, j) == split + 1 ? split + 1 + (n - 1) : split + 1;

    NODE(i).values.xy = ivec2(left, right);
    NODE(left).values.w = i;
    NODE(right).values.w = i;
}

void setLeaf(int i)
{
    uint origInd = triIndices[i - (n - 1)];
    calcTriangleBox(triangles[origInd], NODE(i).min.xyz, NODE(i).max.xyz);
    NODE(i).min.w = origInd;
    // NODE(i).max.w = 1;
    NODE(i).values.z = 1;
    NODE(i).links.x = NODE(i).links.y;
}

void buildLinksAndLeafs(int i)
{
    if (i >= n - 1) return;

    int left = int(NODE(i).values.x);
    int right = int(NODE(i).values.y);
    int parent = int(NODE(i).values.w);

    NODE(i).links.x = left;
    NODE(left).links.y = right;

    if (parent != -1) {
        int curr = right;
        do {
            curr = int(NODE(curr).values.w);
            if (int(NODE(curr).values.w) == -1)
            {
                NODE(right).links.y = -1;
                break;
            }
            NODE(right).links.y = NODE(int(NODE(curr).values.w)).values.y;
        }
        while (int(NODE(right).links.y) == curr);
    }

    if (left >= n - 1) setLeaf(left);
    if (right >= n - 1) setLeaf(right);
}

void calcBoxes(int i)
{
    if (i >= n) return;

    int curr = NODE(i + n - 1).values.w;
    while (curr != -1)
    {
        if (atomicAdd(NODE(curr).links.z, 1) == 0) return;

        BVHNode node = NODE(curr);
        node.min.xyz = min(NODE(node.values.x).min.xyz, NODE(node.values.y).min.xyz);
        node.max.xyz = max(NODE(node.values.x).max.xyz, NODE(node.values.y).max.xyz);
        NODE(curr) = node;

        curr = NODE(curr).values.w;
    }
}

uniform int pass = -1;
void main()
{
    int gid = int(gl_GlobalInvocationID.x);
    if (pass == 0)
    {
        if (gid >= n) return;
        NODE(gid).links = ivec4(-1, -1, 0, 0);
    }
    else if (pass == 1)
        buildInnerNodes(gid);
    else if (pass == 2)
        buildLinksAndLeafs(gid);
    else if (pass == 3)
        calcBoxes(gid);
}
