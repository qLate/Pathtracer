#version 460 core
/// #include "default/_shaderBase.glsl"

const float GRID_RESOLUTION = 1023;

layout(local_size_x = 256) in;

layout(std140, binding = 8) /*buffer*/ uniform TriangleCenters
{
    vec3 centers[];
};

layout(std430, binding = 9) /*buffer*/ uniform MortonCodes
{
    uint mortonCodes[];
};

layout(std140, binding = 10) /*buffer*/ uniform MinMax {
    ivec3 globalMinUint;
    ivec3 globalMaxUint;
};

layout(std140, binding = 11) /*buffer*/ uniform MinMaxFloat {
    vec3 globalMin;
    vec3 globalMax;
};

shared vec3 localMin[256];
shared vec3 localMax[256];

void computeBounds(vec3 value) {
    uint lid = gl_LocalInvocationID.x;
    uint groupSize = gl_WorkGroupSize.x;

    if (lid == 0) {
        globalMinUint = ivec3(floatBitsToUint(FLT_MAX));
        globalMaxUint = ivec3(floatBitsToUint(FLT_MIN));
    }

    localMin[lid] = value;
    localMax[lid] = value;

    barrier();

    for (uint s = groupSize / 2; s > 0; s >>= 1) {
        if (lid < s) {
            localMin[lid] = min(localMin[lid], localMin[lid + s]);
            localMax[lid] = max(localMax[lid], localMax[lid + s]);
        }
        barrier();
    }
    barrier();

    if (lid == 0) {
        atomicMin(globalMinUint.x, floatBitsToInt(localMin[0].x));
        atomicMin(globalMinUint.y, floatBitsToInt(localMin[0].y));
        atomicMin(globalMinUint.z, floatBitsToInt(localMin[0].z));

        atomicMax(globalMaxUint.x, floatBitsToInt(localMax[0].x));
        atomicMax(globalMaxUint.y, floatBitsToInt(localMax[0].y));
        atomicMax(globalMaxUint.z, floatBitsToInt(localMax[0].z));
    }
}

uint expandBits(uint x) {
    x = (x | x << 16) & 0x030000FF;
    x = (x | x << 8) & 0x0300F00F;
    x = (x | x << 4) & 0x030C30C3;
    x = (x | x << 2) & 0x09249249;
    return x;
}

uint computeMortonCode(vec3 point, vec3 minBound, vec3 maxBound) {
    vec3 normalized = (point - minBound) / (maxBound - minBound);
    ivec3 grid = ivec3(normalized * GRID_RESOLUTION);

    return expandBits(grid.x) | (expandBits(grid.y) << 1) | (expandBits(grid.z) << 2);
}

void generateMortonCode(uint i, int n)
{
    centers[i] = getTriangleCenter(triangles[i]);

    barrier();
    computeBounds(centers[i]);

    barrier();
    globalMin = vec3(intBitsToFloat(globalMinUint.x), intBitsToFloat(globalMinUint.y), intBitsToFloat(globalMinUint.z));
    globalMax = vec3(intBitsToFloat(globalMaxUint.x), intBitsToFloat(globalMaxUint.y), intBitsToFloat(globalMaxUint.z));

    barrier();
    mortonCodes[i] = computeMortonCode(centers[i], globalMin, globalMax);
}

void main() {
    uint index = gl_GlobalInvocationID.x;
    if (index >= triangles.length()) return;

    generateMortonCode(index, triangles.length());
}
